<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>loserbunny</title>
<style>
  :root{
    --bg:#03030a;
    --moon:#cfe8ff;
    --fog1:rgba(255,255,255,0.035);
    --fog2:rgba(255,255,255,0.07);
    --whisper:#dfe8e8;
  }
  html,body{height:100%;margin:0;background:radial-gradient(circle at 20% 10%, #071021 0%, var(--bg) 25%, #000 100%);font-family:Verdana, Geneva, Tahoma, sans-serif;color:var(--whisper);overflow:hidden}

  .stage{height:100vh;display:flex;align-items:center;justify-content:center}
  .scene{position:relative;width:100%;max-width:1200px;height:82vh;max-height:920px;border-radius:6px;overflow:hidden}

  /* distant moon glow */
  .moon{position:absolute;right:18%;top:6%;width:420px;height:420px;border-radius:50%;background:radial-gradient(circle at 40% 30%, rgba(207,232,255,0.12), transparent 40%);filter:blur(36px);opacity:.9;pointer-events:none}

  /* slow drifting layered fog (CSS-only) */
  .fog{position:absolute;inset:0;pointer-events:none}
  .fog .layer{position:absolute;left:-10%;top:-20%;width:120%;height:140%;background:linear-gradient(180deg,var(--fog2),transparent);opacity:0.6;filter:blur(28px);animation:drift 40s linear infinite}
  .fog .layer.b{left:-15%;top:-30%;width:140%;height:160%;opacity:0.45;filter:blur(44px);animation-duration:56s}
  .fog .layer.c{left:-5%;top:-10%;width:110%;height:120%;opacity:0.32;filter:blur(18px);animation-duration:28s}
  @keyframes drift{0%{transform:translateX(-10%)}50%{transform:translateX(10%)}100%{transform:translateX(-10%)}}

  /* ground shadow */
  .ground{position:absolute;left:0;right:0;bottom:0;height:26%;background:linear-gradient(180deg,transparent,rgba(0,0,0,0.72));pointer-events:none}

  /* bunny wrapper and approach animation */
  .bunny-wrap{position:absolute;right:6%;bottom:10%;width:420px;height:620px;transform-origin:center bottom;pointer-events:none}
  .bunny{width:100%;height:100%;display:block;filter:contrast(90%)}
  @keyframes approach{0%{transform:translateY(8%) scale(0.56)}40%{transform:translateY(4%) scale(0.8)}100%{transform:translateY(-2%) scale(1.12)}}
  .bunny-anim{animation:approach 26s ease-in-out infinite}

  /* rim layer for subtle moonlight on left */
  .rim{position:absolute;right:6%;bottom:10%;width:420px;height:620px;pointer-events:none;opacity:0.12}

  /* whisper text UI */
  .controls{position:fixed;left:14px;top:14px;font-size:13px;color:#9aa4ad}
  .mute{background:transparent;border:1px solid rgba(255,255,255,0.04);color:#9aa4ad;padding:8px 10px;border-radius:6px;cursor:pointer}

  .whisper{position:absolute;left:6%;bottom:6%;font-size:22px;color:var(--whisper);opacity:0.95;letter-spacing:0.6px}
  .whisper .glitch{position:relative;display:inline-block}
  .whisper .glitch::before,.whisper .glitch::after{content:attr(data-text);position:absolute;left:0;top:0;opacity:0.12}
  .whisper .glitch::before{transform:translate(2px,-2px)}
  .whisper .glitch::after{transform:translate(-2px,2px)}

  /* smaller screens */
  @media (max-width:900px){.bunny-wrap{width:340px;height:500px;right:5%}}
  @media (max-width:520px){.bunny-wrap{display:none}.whisper{font-size:16px}}
</style>
</head>
<body>
  <div class="controls">Press <strong>M</strong> to mute/unmute whisper â€” <button class="mute" id="toggle">Mute</button></div>
  <div class="stage">
    <div class="scene" role="img" aria-label="A night sky with drifting fog and a shadowy bunny slowly approaching from the right">

      <div class="moon" aria-hidden="true"></div>
      <div class="fog" aria-hidden="true">
        <div class="layer a"></div>
        <div class="layer b"></div>
        <div class="layer c"></div>
      </div>

      <div class="ground" aria-hidden="true"></div>

      <div class="bunny-wrap" aria-hidden="true">
        <!-- realistic-looking silhouette built with clean shapes and a faint inner gradient -->
        <svg class="bunny bunny-anim" viewBox="0 0 400 600" xmlns="http://www.w3.org/2000/svg" preserveAspectRatio="xMidYMax meet">
          <defs>
            <linearGradient id="shade" x1="0" x2="0" y1="0" y2="1">
              <stop offset="0%" stop-color="#000" stop-opacity="0.96"/>
              <stop offset="100%" stop-color="#000" stop-opacity="0.98"/>
            </linearGradient>
          </defs>
          <g>
            <ellipse cx="200" cy="470" rx="150" ry="100" fill="url(#shade)" />
            <ellipse cx="200" cy="340" rx="92" ry="86" fill="url(#shade)" />
            <path d="M160 190 C138 110, 130 320, 158 260" fill="#000"/>
            <path d="M270 170 C298 88, 312 320, 278 260" fill="#000"/>
            <ellipse cx="200" cy="468" rx="76" ry="42" fill="#000" opacity="0.52" />
            <ellipse cx="154" cy="328" rx="96" ry="96" fill="rgba(255,255,255,0.03)" />
          </g>
        </svg>
        <!-- rim highlight -->
        <svg class="rim" viewBox="0 0 400 600" xmlns="http://www.w3.org/2000/svg" preserveAspectRatio="xMidYMax meet">
          <defs>
            <radialGradient id="r" cx="25%" cy="30%">
              <stop offset="0%" stop-color="#dfe9e9" stop-opacity="0.12" />
              <stop offset="100%" stop-color="#000" stop-opacity="0" />
            </radialGradient>
          </defs>
          <g>
            <ellipse cx="154" cy="328" rx="110" ry="110" fill="url(#r)" />
          </g>
        </svg>
      </div>

      <div class="whisper" aria-hidden="true"><span class="glitch" data-text="loser... loser...">loser... loser...</span></div>
    </div>
  </div>

<script>
// Lightweight WebAudio + SpeechSynthesis whisper combo.
// Uses SpeechSynthesis when available for human-like whisper; falls back to generated ambient noise + periodic muffled whisper-like tones.
(function(){
  const toggle = document.getElementById('toggle');
  let muted = false;

  function setButton(){ toggle.textContent = muted ? 'Unmute' : 'Mute'; }
  setButton();

  toggle.addEventListener('click', ()=>{ muted = !muted; setButton(); updateAudio(); });
  window.addEventListener('keydown', (e)=>{ if(e.key.toLowerCase()==='m'){ muted = !muted; setButton(); updateAudio(); }});

  // SpeechSynthesis approach
  let synthAvailable = 'speechSynthesis' in window;
  let synthTimer;

  // WebAudio ambient noise (always present if synth not used)
  let audioCtx, noiseNode, gainNode;
  function initAudio(){
    try{
      audioCtx = new (window.AudioContext || window.webkitAudioContext)();
      // create noise
      const bufferSize = 2 * audioCtx.sampleRate;
      const buffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate);
      const data = buffer.getChannelData(0);
      for(let i=0;i<bufferSize;i++) data[i] = (Math.random()*2-1)*0.25; // low volume
      noiseNode = audioCtx.createBufferSource();
      noiseNode.buffer = buffer; noiseNode.loop = true;
      gainNode = audioCtx.createGain(); gainNode.gain.value = 0.02;
      noiseNode.connect(gainNode).connect(audioCtx.destination);
      noiseNode.start(0);
    }catch(e){console.warn('Audio init failed',e)}
  }

  function speakWhisperLine(text){
    if(muted) return;
    if(synthAvailable){
      // create slightly breathy whisper effect using low rate/pitch and soft volume
      const u = new SpeechSynthesisUtterance(text);
      u.rate = 0.8; u.pitch = 0.6; u.volume = 0.4;
      // choose an English voice if possible
      const voices = window.speechSynthesis.getVoices();
      if(voices && voices.length) u.voice = voices.find(v=>/en|us|uk/i.test(v.lang)) || voices[0];
      window.speechSynthesis.cancel();
      window.speechSynthesis.speak(u);
    }
  }

  function startWhisperLoop(){
    // periodic whispers with slight random delays for creepiness
    function loop(){
      if(muted) return;
      speakWhisperLine('loser...');
      // after 1s speak second part softly
      setTimeout(()=>{ if(!muted) speakWhisperLine('loser...'); }, 1200 + Math.random()*800);
      // schedule next loop
      synthTimer = setTimeout(loop, 4200 + Math.random()*2600);
    }
    loop();
  }

  function stopWhisperLoop(){
    if(synthTimer) clearTimeout(synthTimer);
    if(synthAvailable) window.speechSynthesis.cancel();
  }

  function updateAudio(){
    if(muted){ stopWhisperLoop(); if(gainNode) gainNode.gain.setValueAtTime(0, audioCtx.currentTime); return; }
    // ensure audio context started (user gesture may be required on some browsers)
    if(!audioCtx) initAudio();
    if(gainNode) gainNode.gain.setValueAtTime(0.02, audioCtx.currentTime);
    if(synthAvailable) startWhisperLoop();
  }

  // try to prime voices (some browsers load voices asynchronously)
  if(synthAvailable){ window.speechSynthesis.onvoiceschanged = ()=>{}; }

  // start automatically but respect autoplay policies: user gesture may be required for audio
  // we still initialize silent noise so visuals work without user interaction
  initAudio();
  // try start whisper loop; if brower blocks audio, user can press M or click mute toggle to enable
  setTimeout(()=>{ updateAudio(); }, 800);

})();
</script>
</body>
</html>

